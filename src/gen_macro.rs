macro_rules! gen_wrapper {

    // Macro for built-in types with additional arguments

    // Macro usage example:
    //
    // gen_wrapper!(kth_stat, (kth_elem_f64_py, [k::usize] => f64),
    //                        (kth_elem_f32_py, [k::usize] => f32)
    //             )
    //
    // Briefly this means the following:
    //
    // 1) There is a rust function kth_stat exists somewhere;
    // 2) Two function will be generated: kth_elem_f64_py and kth_elem_f32_py each of which accept
    //    variable of type Python as its first argument, variable of type PyObject as its second
    //    argument and variable of type usize as the third one;
    // 3) First two arguments are implicit and need not be declared, third argument may be
    //    provided if necessary;
    // 4) kth_elem_f64_py and kth_elem_f32_py then must be used by rust-cpython library
    //    as wrappers between python and rust code;
    //
    // Example of code generated by gen_wrapper!(kth_stat, (kth_elem_f64_py, [k::usize] => f64)):
    //
    // crate fn $func_name(py: Python<'_>, xs: PyObject, k: usize) -> PyResult<f64> {
    //      let ys = pylist_to_vec(py, xs)?;
    //      to_python_result(py, kth_stat(ys, k))
    // }

    // rust func name to be called from python, kth_stat for example
    ($rust_func_name:ident,

        // name of a function which will interact with both python and rust, performs conversions
        // between python and rust lists and return types
        $( ($func_name:ident, [$($arg:ident:: $arg_type:ty),*] => $ret_type:ty) ),+) => {

        $(
            // generate wrapper function
            crate fn $func_name(py: Python<'_>, xs: PyObject, $($arg: $arg_type)*) ->
                                                                        PyResult<$ret_type> {
                let ys = pylist_to_vec(py, xs)?;
                to_python_result(py, stat_funcs::$rust_func_name(ys, $($arg)*))
            }
        )+

    };


    (mut $rust_func_name:ident, $( ($func_name:ident, [$($arg:ident:: $arg_type:ty),*] =>
                                                                        $ret_type:ty) ),+) => {
        $(
            crate fn $func_name(py: Python<'_>, xs: PyObject, $($arg: $arg_type)*) ->
                                                                            PyResult<$ret_type> {
                let mut ys = pylist_to_vec(py, xs)?;
                to_python_result(py, stat_funcs::$rust_func_name(&mut ys, $($arg)*))
            }
        )+
    };

    // Macro rules for ordered floats

    (ord $rust_func_name:ident, $( ($func_name:ident, $ret_type:ty) ),+) => {
        $(
            crate fn $func_name(py: Python<'_>, xs: PyObject) -> PyResult<$ret_type> {
                let ys = extract_ordered_floats(py, &xs)?;
                let res = stat_funcs::$rust_func_name::<OrderedFloat<$ret_type>>(ys);
                to_python_result(py, res.map(|x| x.into()))
            }
        )+
    };

    (ord mut $rust_func_name:ident, $( ($func_name:ident, $ret_type:ty) ),+) => {
        $(
            crate fn $func_name(py: Python<'_>, xs: PyObject) -> PyResult<$ret_type> {
                let mut ys = extract_ordered_floats(py, &xs)?;
                let res = stat_funcs::$rust_func_name::<OrderedFloat<$ret_type>>(&mut ys);
                to_python_result(py, res.map(|x| x.into()))
            }
        )+
    };

}
